<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>BouncingBall - Game</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: Arial, sans-serif;
      height: 100vh;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: flex-start;
      color: #fff;
      position: relative;
      overflow: hidden;
      /* use clean background without the old white bar */
      background-image: url("newimage.png");
      background-size: cover;
      background-position: center;
      background-repeat: no-repeat;
    }

    #gameCanvas {
      position: absolute;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      background-color: transparent;
      z-index: 1;
    }

    .game-over {
      display: none;
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(0, 0, 0, 0.85);
      padding: 40px;
      border-radius: 20px;
      text-align: center;
      z-index: 100;
      color: white;
    }

    .game-over.visible {
      display: block;
    }

    .game-over h2 {
      font-size: 3rem;
      margin-bottom: 20px;
      color: #ff4444;
      font-weight: 900;
    }

    .game-over.win h2 {
      color: #22c55e;
    }

    .game-over p {
      font-weight: 900;
    }

    .game-over button {
      padding: 15px 40px;
      font-size: 1.5rem;
      font-weight: 900;
      border: none;
      border-radius: 10px;
      background: white;
      color: #0ea5e9;
      cursor: pointer;
      margin-top: 20px;
    }
  </style>
</head>
<body>
  <canvas id="gameCanvas" width="900" height="500"></canvas>

  <div class="game-over" id="gameOver">
    <h2 id="gameOverTitle">GAME OVER!</h2>
    <p id="gameOverText">You touched the sand!</p>
    <button id="restartBtn">Play Again</button>
    <button id="menuBtn" style="display:none;margin-left:12px;">Main Menu</button>
  </div>
  <div id="victoryScreen" style="display:none; position:fixed; inset:0; background:#000; z-index:200; color:#fff; align-items:center; justify-content:center;">
    <div style="text-align:center; margin:auto;">
      <div style="font-size:96px; line-height:1;">ðŸ‘‘</div>
      <h1 style="font-size:48px; margin:12px 0;">You Won</h1>
      <p style="font-weight:700; margin-bottom:18px;">Congratulations â€” you completed all levels!</p>
      <div style="display:flex; gap:12px; justify-content:center; flex-wrap:wrap;">
        <button id="victoryPlayBtn" style="padding:12px 20px; font-size:18px;">Play Again</button>
        <button id="victoryMenuBtn" style="padding:12px 20px; font-size:18px;">Main Menu</button>
      </div>
      <div id="victoryLevelChoices" style="display:none; margin-top:18px;">
        <p style="margin-bottom:8px;">Choose level:</p>
        <div style="display:flex; gap:8px; justify-content:center; flex-wrap:wrap;">
          <button class="victoryLevelBtn" data-level="1">Level 1</button>
          <button class="victoryLevelBtn" data-level="2">Level 2</button>
          <button class="victoryLevelBtn" data-level="3">Level 3</button>
          <button class="victoryLevelBtn" data-level="4">Level 4</button>
          <button class="victoryLevelBtn" data-level="5">Level 5</button>
        </div>
      </div>
    </div>
  </div>

  <script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');

    const gameOverScreen = document.getElementById('gameOver');
    const gameOverTitle = document.getElementById('gameOverTitle');
    const gameOverText = document.getElementById('gameOverText');
    const restartBtn = document.getElementById('restartBtn');
    const menuBtn = document.getElementById('menuBtn');
    const victoryScreen = document.getElementById('victoryScreen');
    const victoryPlayBtn = document.getElementById('victoryPlayBtn');
    const victoryMenuBtn = document.getElementById('victoryMenuBtn');
    const victoryLevelChoices = document.getElementById('victoryLevelChoices');

    // Constants
    const BLOCK_WIDTH = 80;
    const BLOCK_HEIGHT = 50;
    let groundY = canvas.height - BLOCK_HEIGHT;
    const GRAVITY = 0; // No gravity - Breakout style
    const BASE_BALL_SPEED = 6; // starting speed
    let BALL_SPEED = BASE_BALL_SPEED; // adjustable per level
    const SCROLL_SPEED = 2;

    // Ball properties
    let ball = {
      x: canvas.width / 2,
      y: 120,
      radius: 15,
      vx: 0,
      vy: 0,
      color: 'white',
      launched: false
    };

    // Blocks array - type: 'grass' or 'sand' (ground only)
    let blocks = [];

    // Moving log at the top (player controlled)
    let topLog = {
      x: 0,
      y: 90,
      width: 280,
      height: 65,
      vx: 0
    };

    // Game state
    let gameRunning = false;
    let hasHitLog = false; // Track if ball has hit the log
    let ballLaunchTime = 0; // Track when ball was launched
    const LOG_HIT_TIMEOUT = 15000; // 15 seconds to hit the log after launch
    // Log fly-away state
    let logFlying = false;
    let logFlyMessage = '';
    // Track stars collected for win condition
    let starsCollected = 0;
    let stars = []; // Array to hold star objects
    // Leveling
    let currentLevel = 1;
    const MAX_LEVEL = 5;

    function starsRequired(level) {
      return 3 + (level - 1); // Level 1 = 3 stars, Level 2 = 4 stars, etc.
    }

    function doAdvance(next) {
      gameOverScreen.classList.remove('visible');
      currentLevel = next;
      // increase speed slightly
      BALL_SPEED = +(BASE_BALL_SPEED + (currentLevel - 1) * 0.5).toFixed(2);
      // reset state for next level
      starsCollected = 0;
      hasHitLog = false;
      ballLaunchTime = 0;
      resetBall();
      initBlocks();
      initStars();
      gameRunning = true;
      controlsEnabled = true;
      requestAnimationFrame(gameLoop);
    }

    function advanceLevel() {
      if (currentLevel >= MAX_LEVEL) return;
      gameRunning = false;
      controlsEnabled = false;
      const next = currentLevel + 1;
      // show level complete overlay with choice
      gameOverTitle.textContent = 'LEVEL ' + next + ' COMPLETE';
      gameOverText.textContent = 'Proceed to level ' + next + '?\nTarget: ' + starsRequired(next) + ' stars. Speed will increase.';
      // show menu option
      menuBtn.style.display = 'inline-block';
      restartBtn.textContent = 'Next Level';
      // wire buttons
      restartBtn.onclick = () => doAdvance(next);
      menuBtn.onclick = () => { window.location.href = 'index.html'; };
      gameOverScreen.classList.add('visible');
    }
    // Log press (down) animation state
    let logPressed = false;
    let logPressStart = 0;
    const LOG_PRESS_DOWN = 120; // ms down
    const LOG_PRESS_UP = 220; // ms up
    const LOG_PRESS_DEPTH = 26; // px down distance

    // Load images
    const grassImg = new Image();
    const sandImg = new Image();
    const logImg = new Image();
    grassImg.src = 'Grass_Block.png';
    sandImg.src = 'Sand_Block.png';
    logImg.src = 'log.png';

    function initBlocks() {
      blocks = [];
      const cols = Math.ceil(canvas.width / BLOCK_WIDTH) + 2;

      for (let i = 0; i < cols; i++) {
        const typeRand = Math.random();
        const type = typeRand < 0.3 ? 'sand' : 'grass';
        blocks.push({
          x: i * BLOCK_WIDTH,
          y: groundY,
          width: BLOCK_WIDTH,
          height: BLOCK_HEIGHT,
          type
        });
      }
    }

    function initStars() {
      stars = [];
      // Randomly place stars on grass blocks
      for (let block of blocks) {
        if (block.type === 'grass' && Math.random() < 0.4) { // 40% chance of star on grass
          stars.push({
            x: block.x + block.width / 2,
            y: block.y - 30,
            radius: 10,
            collected: false
          });
        }
      }
    }

    function resetBall() {
      // Ball starts centered, not moving, waiting for rightâ€‘click launch
      ball.x = canvas.width / 2;
      ball.y = canvas.height * 0.35;
      ball.vx = 0;
      ball.vy = 0;
      ball.launched = false;
    }

    function checkCollision(ball, block) {
      const ballLeft = ball.x - ball.radius;
      const ballRight = ball.x + ball.radius;
      const ballTop = ball.y - ball.radius;
      const ballBottom = ball.y + ball.radius;

      const blockLeft = block.x;
      const blockRight = block.x + block.width;
      const blockTop = block.y;
      const blockBottom = block.y + block.height;

      return (
        ballRight > blockLeft &&
        ballLeft < blockRight &&
        ballBottom > blockTop &&
        ballTop < blockBottom
      );
    }

    function endGame(win, message) {
      gameRunning = false;
      // show menu option
      menuBtn.style.display = 'inline-block';
      menuBtn.onclick = () => { window.location.href = 'index.html'; };
      restartBtn.textContent = 'Play Again';
      restartBtn.onclick = restartGame;

      gameOverScreen.classList.add('visible');

      if (win) {
        gameOverScreen.classList.add('win');
        gameOverTitle.textContent = 'YOU WIN!';
      } else {
        gameOverScreen.classList.remove('win');
        gameOverTitle.textContent = 'GAME OVER!';
      }

      gameOverText.textContent = message;
    }

    function showVictoryScreen() {
      // hide other overlays
      gameOverScreen.classList.remove('visible');
      victoryScreen.style.display = 'flex';
      victoryLevelChoices.style.display = 'none';
      // play again shows level choices
      victoryPlayBtn.onclick = () => { victoryLevelChoices.style.display = 'block'; };
      victoryMenuBtn.onclick = () => { window.location.href = 'index.html'; };
      // wire level buttons
      const lvlBtns = document.querySelectorAll('.victoryLevelBtn');
      lvlBtns.forEach(b => {
        b.onclick = () => { const lv = b.getAttribute('data-level'); window.location.href = 'game.html?level=' + lv; };
      });
    }

    function startLogFlyAway(message) {
      if (logFlying) return;
      logFlying = true;
      logFlyMessage = message || 'The log flew away!';
      controlsEnabled = false;
      // stop the ball so animation is visible
      ball.vx = 0;
      ball.vy = 0;
      ball.launched = false;
    }

    function update() {
      if (!gameRunning) return;

      // If the log is flying away, animate it upwards until off-screen
      if (logFlying) {
        topLog.y -= 8;
        topLog.x += Math.sin(Date.now() / 150) * 3;
        if (topLog.y + topLog.height < 0) {
          // After animation completes, end the game with stored message
          const msg = logFlyMessage || 'The log flew away!';
          logFlying = false;
          endGame(false, msg);
        }
        return;
      }

      // If the log was just pressed by the ball, animate it down then back up
      if (logPressed) {
        const t = Date.now() - logPressStart;
        if (t < LOG_PRESS_DOWN) {
          // moving down
          const frac = t / LOG_PRESS_DOWN;
          topLog.y = (topLog.baseY || topLog.y) + LOG_PRESS_DEPTH * frac;
        } else if (t < LOG_PRESS_DOWN + LOG_PRESS_UP) {
          // moving up
          const frac = (t - LOG_PRESS_DOWN) / LOG_PRESS_UP;
          topLog.y = (topLog.baseY || topLog.y) + LOG_PRESS_DEPTH * (1 - frac);
        } else {
          // finished
          topLog.y = topLog.baseY || topLog.y;
          logPressed = false;
        }
      }

      // Check if ball hasn't hit log within time limit (after launch)
      if (!hasHitLog && ball.launched && ballLaunchTime > 0) {
        const elapsed = Date.now() - ballLaunchTime;
        if (elapsed > LOG_HIT_TIMEOUT) {
          startLogFlyAway('You took too long to hit the log!');
          return;
        }
      }

      // Move log with arrow keys
      if (controlsEnabled) {
        if (keys.left && topLog.x > 0) {
          topLog.x -= 5;
        }
        if (keys.right && topLog.x < canvas.width - topLog.width) {
          topLog.x += 5;
        }
      }

      // Scroll blocks to the left
      for (let block of blocks) {
        block.x -= SCROLL_SPEED;
      }

      // Scroll stars to the left
      for (let star of stars) {
        star.x -= SCROLL_SPEED;
      }

      // Recycle blocks that move off screen
      for (let block of blocks) {
        if (block.x + block.width < 0) {
          block.x = Math.max(...blocks.map(b => b.x)) + BLOCK_WIDTH;

          const typeRand = Math.random();
          block.type = typeRand < 0.2 ? 'sand' : 'grass';
          
          // Remove old stars and generate new ones
          stars = stars.filter(s => s.x > 0);
          if (block.type === 'grass' && Math.random() < 0.4) {
            stars.push({
              x: block.x + block.width / 2,
              y: block.y - 30,
              radius: 10,
              collected: false
            });
          }
        }
      }

      // Ball physics only after launch - Breakout style (constant speed)
      if (ball.launched) {
        // Normalize velocity to maintain constant speed
        const speed = Math.sqrt(ball.vx * ball.vx + ball.vy * ball.vy);
        if (speed > 0) {
          ball.vx = (ball.vx / speed) * BALL_SPEED;
          ball.vy = (ball.vy / speed) * BALL_SPEED;
        }
        ball.x += ball.vx;
        ball.y += ball.vy;
        
        // Check if ball goes above/over the log - lose condition
        // Ball is above the log if its bottom edge is above the log's top edge
        if (ball.y + ball.radius < topLog.y) {
          if (!hasHitLog) {
            startLogFlyAway('The ball went over the log before hitting it!');
          } else {
            endGame(false, 'The ball went over the log!');
          }
          return;
        }
      }

      // Wall collisions - Breakout style (perfect bounces)
      if (ball.x - ball.radius <= 0) {
        ball.x = ball.radius;
        ball.vx = Math.abs(ball.vx); // Bounce right
      } else if (ball.x + ball.radius >= canvas.width) {
        ball.x = canvas.width - ball.radius;
        ball.vx = -Math.abs(ball.vx); // Bounce left
      }

      // Top of screen
      if (ball.y - ball.radius <= 0) {
        ball.y = ball.radius;
        ball.vy = Math.abs(ball.vy); // Bounce down
      }

      // If ball falls below bottom, lose (only if hasn't hit log yet)
      if (ball.y - ball.radius > canvas.height + 50) {
        if (!hasHitLog) {
          startLogFlyAway('You fell off before hitting the log!');
        } else {
          endGame(false, 'You fell off the screen!');
        }
        return;
      }

      // Collisions with blocks - Breakout style
      for (let block of blocks) {
        if (checkCollision(ball, block)) {
          if (block.type === 'sand') {
            if (!hasHitLog) {
                startLogFlyAway('You hit sand before hitting the log!');
            } else {
              endGame(false, 'You hit a sand block!');
            }
            return;
          }
          // For grass: Breakout-style bounce (no win condition tied to grass anymore)
          if (block.type === 'grass') {
            // Determine which side of the block was hit
            const ballCenterX = ball.x;
            const ballCenterY = ball.y;
            const blockCenterX = block.x + block.width / 2;
            const blockCenterY = block.y + block.height / 2;
            
            const dx = ballCenterX - blockCenterX;
            const dy = ballCenterY - blockCenterY;
            
            // Bounce based on which side is closer (Breakout style)
            if (Math.abs(dx) > Math.abs(dy)) {
              // Hit from left or right
              ball.vx = -ball.vx;
              if (dx > 0) {
                ball.x = block.x + block.width + ball.radius;
              } else {
                ball.x = block.x - ball.radius;
              }
            } else {
              // Hit from top or bottom
              ball.vy = -ball.vy;
              if (dy > 0) {
                ball.y = block.y + block.height + ball.radius;
              } else {
                ball.y = block.y - ball.radius;
              }
            }
            break;
          }
        }
      }

      // Star collection
      for (let star of stars) {
        if (!star.collected) {
          const dx = star.x - ball.x;
          const dy = star.y - ball.y;
          const dist = Math.sqrt(dx * dx + dy * dy);
          
          if (dist < star.radius + ball.radius) {
            star.collected = true;
            starsCollected++;
            
            const target = starsRequired(currentLevel);
            if (starsCollected >= target) {
              if (currentLevel >= MAX_LEVEL) {
                // show special victory screen for finishing level 5
                showVictoryScreen();
                return;
              } else {
                advanceLevel();
                return;
              }
            }
          }
        }
      }

      

      // Collision with moving top log - Breakout paddle style
      const fakeBlock = {
        x: topLog.x,
        y: topLog.y,
        width: topLog.width,
        height: topLog.height
      };
      if (checkCollision(ball, fakeBlock)) {
        // Mark that the ball has hit the log
        if (!hasHitLog) {
          hasHitLog = true;
        }
        // trigger press animation
        logPressed = true;
        logPressStart = Date.now();
        
        // Breakout-style paddle bounce: angle depends on where ball hits the log
        const ballCenterX = ball.x;
        const logCenterX = topLog.x + topLog.width / 2;
        const logLeft = topLog.x;
        const logRight = topLog.x + topLog.width;
        
        // Calculate hit position relative to center (-1 to 1)
        const hitPos = (ballCenterX - logCenterX) / (topLog.width / 2);
        const clampedHitPos = Math.max(-1, Math.min(1, hitPos));
        
        // Determine collision side
        const fromTop = ball.y < topLog.y;
        const fromBottom = ball.y > topLog.y + topLog.height;
        
        if (fromTop || fromBottom) {
          // Angle-based bounce: hit from top -> bounce up; hit from bottom -> bounce down
          const maxAngle = Math.PI / 3; // 60 degrees
          const angle = clampedHitPos * maxAngle;
          const speed = BALL_SPEED;
          if (fromTop) {
            // Place ball above the log and send it upward
            ball.y = topLog.y - ball.radius;
            ball.vx = Math.sin(angle) * speed;
            ball.vy = -Math.abs(Math.cos(angle) * speed);
          } else {
            // Place ball below the log and send it downward
            ball.y = topLog.y + topLog.height + ball.radius;
            ball.vx = Math.sin(angle) * speed;
            ball.vy = Math.abs(Math.cos(angle) * speed);
          }
        } else {
          // Hit from side - simple horizontal bounce
          if (ball.x < topLog.x) {
            ball.x = topLog.x - ball.radius;
            ball.vx = -Math.abs(ball.vx);
          } else {
            ball.x = topLog.x + topLog.width + ball.radius;
            ball.vx = Math.abs(ball.vx);
          }
        }
      }
    }

    function draw() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      // Draw blocks (ground)
      for (let block of blocks) {
        if (block.type === 'grass') {
          ctx.drawImage(grassImg, block.x, block.y, block.width, block.height);
        } else if (block.type === 'sand') {
          ctx.drawImage(sandImg, block.x, block.y, block.width, block.height);
        }
      }

      // Draw stars
      for (let star of stars) {
        if (!star.collected) {
          ctx.fillStyle = '#FFD700'; // Gold color
          ctx.beginPath();
          ctx.arc(star.x, star.y, star.radius, 0, Math.PI * 2);
          ctx.fill();
          ctx.strokeStyle = '#FFA500';
          ctx.lineWidth = 2;
          ctx.stroke();
        }
      }

      // Draw moving top log
      ctx.drawImage(logImg, topLog.x, topLog.y, topLog.width, topLog.height);

      // Draw ball (simple white circle)
      ctx.beginPath();
      ctx.arc(ball.x, ball.y, ball.radius, 0, Math.PI * 2);
      ctx.fillStyle = ball.color;
      ctx.fill();
      ctx.strokeStyle = '#333';
      ctx.lineWidth = 2;
      ctx.stroke();

      // Draw stars collected counter
      ctx.fillStyle = 'white';
      ctx.font = 'bold 24px Arial';
      ctx.fillText('Stars: ' + starsCollected + ' / ' + starsRequired(currentLevel), 20, 40);
      ctx.fillText('Level: ' + currentLevel, 20, 70);
    }

    function resizeCanvas() {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
      groundY = canvas.height - BLOCK_HEIGHT;

      // keep ground stuck to bottom
      for (let block of blocks) {
        block.y = groundY;
      }

      // keep top log centered horizontally on resize
        topLog.y = canvas.height * 0.2;
        topLog.x = canvas.width / 2 - topLog.width / 2;
        // store baseY so press animation returns properly
        topLog.baseY = topLog.y;

      // make sure ball isn't below ground after resize
      if (ball.y > groundY - ball.radius) {
        ball.y = groundY - ball.radius;
        ball.vy = 0;
      }
    }

    function gameLoop() {
      if (!gameRunning) return;
      update();
      draw();
      requestAnimationFrame(gameLoop);
    }

    function startGame() {
      document.body.style.backgroundImage = 'url("back.png")';
      document.body.style.backgroundSize = 'cover';
      document.body.style.backgroundPosition = 'center';
      document.body.style.backgroundRepeat = 'no-repeat';
      resizeCanvas();
      initBlocks();
      // Read level from URL param if provided
      const params = new URLSearchParams(window.location.search);
      const lvl = parseInt(params.get('level')) || 1;
      currentLevel = Math.min(MAX_LEVEL, Math.max(1, lvl));
      // initialize level-specific values
      BALL_SPEED = +(BASE_BALL_SPEED + (currentLevel - 1) * 0.5).toFixed(2);
      resetBall();
      hasHitLog = false; // Reset log hit status
      starsCollected = 0; // reset stars collected
      ballLaunchTime = 0; // Reset launch timer
      initStars();
      gameOverScreen.classList.remove('visible');
      gameRunning = true;
      controlsEnabled = true;
      gameLoop();
    }

    function restartGame() {
      // Restart the current level without changing it
      starsCollected = 0;
      hasHitLog = false;
      ballLaunchTime = 0;
      logFlying = false;
      logFlyMessage = '';
      resetBall();
      initBlocks();
      initStars();
      BALL_SPEED = +(BASE_BALL_SPEED + (currentLevel - 1) * 0.5).toFixed(2);
      gameOverScreen.classList.remove('visible');
      gameRunning = true;
      controlsEnabled = true;
      requestAnimationFrame(gameLoop);
    }

    // default restart button handler (used on game over)
    restartBtn.onclick = restartGame;

    // Input state for log movement
    let controlsEnabled = false;
    const keys = {
      left: false,
      right: false
    };

    // When mouse is pressed (left click to move log)
    canvas.addEventListener('mousedown', (e) => {
      if (!gameRunning) return;

      if (e.button === 0) {
        // Left click to move log
        const rect = canvas.getBoundingClientRect();
        const mouseX = e.clientX - rect.left;
        topLog.x = mouseX - topLog.width / 2;
        if (topLog.x < 0) topLog.x = 0;
        if (topLog.x > canvas.width - topLog.width) topLog.x = canvas.width - topLog.width;
      }
    });

    // Move the log continuously with mouse movement
    canvas.addEventListener('mousemove', (e) => {
      if (!gameRunning || logFlying) return;
      const rect = canvas.getBoundingClientRect();
      const mouseX = e.clientX - rect.left;
      topLog.x = mouseX - topLog.width / 2;
      if (topLog.x < 0) topLog.x = 0;
      if (topLog.x > canvas.width - topLog.width) topLog.x = canvas.width - topLog.width;
    });

    // Arrow key handling for log movement (only while controlsEnabled)
    window.addEventListener('keydown', (e) => {
      if (!controlsEnabled) return;
      if (e.key === 'ArrowLeft') {
        keys.left = true;
      } else if (e.key === 'ArrowRight') {
        keys.right = true;
      } else if (e.key === ' ' && !ball.launched) {
        // Space to launch ball vertically upward
        ball.launched = true;
        ballLaunchTime = Date.now(); // Start timer when ball is launched
        ball.vx = 0;
        ball.vy = -BALL_SPEED; // Negative = upward
      }
    });

    window.addEventListener('keyup', (e) => {
      if (e.key === 'ArrowLeft') {
        keys.left = false;
      } else if (e.key === 'ArrowRight') {
        keys.right = false;
      }
    });

    // Start when page loads
    window.addEventListener('load', () => {
      resizeCanvas();
      startGame();
    });

    // Resize handler for full-screen behaviour
    window.addEventListener('resize', () => {
      resizeCanvas();
      // re-generate blocks to fill new width
      initBlocks();
    });
  </script>
</body>
</html>
