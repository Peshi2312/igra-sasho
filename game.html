<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>BouncingBall - Game</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: Arial, sans-serif;
      height: 100vh;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: flex-start;
      color: #fff;
      position: relative;
      overflow: hidden;
      /* use clean background without the old white bar */
      background-image: url("newimage.png");
      background-size: cover;
      background-position: center;
      background-repeat: no-repeat;
    }

    #gameCanvas {
      position: absolute;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      background-color: transparent;
      z-index: 1;
    }

    .game-over {
      display: none;
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(0, 0, 0, 0.85);
      padding: 40px;
      border-radius: 20px;
      text-align: center;
      z-index: 100;
      color: white;
    }

    .game-over.visible {
      display: block;
    }

    .game-over h2 {
      font-size: 3rem;
      margin-bottom: 20px;
      color: #ff4444;
      font-weight: 900;
    }

    .game-over.win h2 {
      color: #22c55e;
    }

    .game-over p {
      font-weight: 900;
    }

    .game-over button {
      padding: 15px 40px;
      font-size: 1.5rem;
      font-weight: 900;
      border: none;
      border-radius: 10px;
      background: white;
      color: #0ea5e9;
      cursor: pointer;
      margin-top: 20px;
    }
  </style>
</head>
<body>
  <canvas id="gameCanvas" width="900" height="500"></canvas>

  <div class="game-over" id="gameOver">
    <h2 id="gameOverTitle">GAME OVER!</h2>
    <p id="gameOverText">You touched the sand!</p>
    <button id="restartBtn">Play Again</button>
  </div>

  <script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');

    const gameOverScreen = document.getElementById('gameOver');
    const gameOverTitle = document.getElementById('gameOverTitle');
    const gameOverText = document.getElementById('gameOverText');
    const restartBtn = document.getElementById('restartBtn');

    // Constants
    const BLOCK_WIDTH = 80;
    const BLOCK_HEIGHT = 50;
    let groundY = canvas.height - BLOCK_HEIGHT;
    const GRAVITY = 0.20;
    const BOUNCE_FACTOR = 1.0;
    const LOG_BOUNCE_FACTOR = 1.0;
    const SCROLL_SPEED = 2;
    const BALL_SPEED = 18;

    // Ball properties
    let ball = {
      x: canvas.width / 2,
      y: 120,
      radius: 15,
      vx: 0,
      vy: 0,
      color: 'white',
      launched: false
    };

    // Blocks array - type: 'grass' or 'sand' (ground only)
    let blocks = [];

    // Moving log at the top (player controlled)
    let topLog = {
      x: 0,
      y: 90,
      width: 280,
      height: 65,
      vx: 0
    };

    // Game state
    let gameRunning = false;

    // Load images
    const grassImg = new Image();
    const sandImg = new Image();
    const logImg = new Image();
    grassImg.src = 'Grass_Block.png';
    sandImg.src = 'Sand_Block.png';
    logImg.src = 'log.png';

    function initBlocks() {
      blocks = [];
      const cols = Math.ceil(canvas.width / BLOCK_WIDTH) + 2;

      for (let i = 0; i < cols; i++) {
        const typeRand = Math.random();
        const type = typeRand < 0.3 ? 'sand' : 'grass';
        blocks.push({
          x: i * BLOCK_WIDTH,
          y: groundY,
          width: BLOCK_WIDTH,
          height: BLOCK_HEIGHT,
          type
        });
      }
    }

    function resetBall() {
      // Ball starts centered, not moving, waiting for rightâ€‘click launch
      ball.x = canvas.width / 2;
      ball.y = canvas.height * 0.35;
      ball.vx = 0;
      ball.vy = 0;
      ball.launched = false;
    }

    function checkCollision(ball, block) {
      const ballLeft = ball.x - ball.radius;
      const ballRight = ball.x + ball.radius;
      const ballTop = ball.y - ball.radius;
      const ballBottom = ball.y + ball.radius;

      const blockLeft = block.x;
      const blockRight = block.x + block.width;
      const blockTop = block.y;
      const blockBottom = block.y + block.height;

      return (
        ballRight > blockLeft &&
        ballLeft < blockRight &&
        ballBottom > blockTop &&
        ballTop < blockBottom
      );
    }

    function endGame(win, message) {
      gameRunning = false;
      gameOverScreen.classList.add('visible');

      if (win) {
        gameOverScreen.classList.add('win');
        gameOverTitle.textContent = 'YOU WIN!';
      } else {
        gameOverScreen.classList.remove('win');
        gameOverTitle.textContent = 'GAME OVER!';
      }

      gameOverText.textContent = message;
    }

    function update() {
      if (!gameRunning) return;

      // Move log with arrow keys
      if (controlsEnabled) {
        if (keys.left && topLog.x > 0) {
          topLog.x -= 5;
        }
        if (keys.right && topLog.x < canvas.width - topLog.width) {
          topLog.x += 5;
        }
      }

      // Scroll blocks to the left
      for (let block of blocks) {
        block.x -= SCROLL_SPEED;
      }

      // Recycle blocks that move off screen
      for (let block of blocks) {
        if (block.x + block.width < 0) {
          block.x = Math.max(...blocks.map(b => b.x)) + BLOCK_WIDTH;

          const typeRand = Math.random();
          block.type = typeRand < 0.2 ? 'sand' : 'grass';
        }
      }

      // Ball physics only after launch
      if (ball.launched) {
        ball.vy += GRAVITY;
        ball.x += ball.vx;
        ball.y += ball.vy;
      }

      // Wall collisions
      if (ball.x - ball.radius <= 0) {
        ball.x = ball.radius;
        ball.vx = Math.abs(ball.vx);
      } else if (ball.x + ball.radius >= canvas.width) {
        ball.x = canvas.width - ball.radius;
        ball.vx = -Math.abs(ball.vx);
      }

      // Top of screen
      if (ball.y - ball.radius <= 0) {
        ball.y = ball.radius;
        ball.vy = Math.abs(ball.vy);
      }

      // If ball falls below bottom, lose
      if (ball.y - ball.radius > canvas.height + 50) {
        endGame(false, 'You fell off the screen!');
        return;
      }

      // Collisions with blocks (only when moving downwards)
      if (ball.vy >= 0) {
        for (let block of blocks) {
          if (checkCollision(ball, block)) {
            // Place ball on top of block
            ball.y = block.y - ball.radius;
            ball.vy = -Math.abs(ball.vy) * BOUNCE_FACTOR;

            if (block.type === 'sand') {
              endGame(false, 'You hit a sand block!');
              return;
            }
            // For grass we simply bounce and keep going
            break;
          }
        }
      }

      // Collision with moving top log
      const fakeBlock = {
        x: topLog.x,
        y: topLog.y,
        width: topLog.width,
        height: topLog.height
      };
      if (checkCollision(ball, fakeBlock)) {
        // Determine if we hit from top or bottom or the sides
        const fromTop = ball.y < topLog.y;
        const fromBottom = ball.y > topLog.y + topLog.height;

        if (fromTop || fromBottom) {
          // vertical bounce
          ball.vy = -Math.abs(ball.vy) * LOG_BOUNCE_FACTOR;
          if (fromTop) {
            ball.y = topLog.y - ball.radius;
          } else {
            ball.y = topLog.y + topLog.height + ball.radius;
          }
        } else {
          // side bounce
          ball.vx = -ball.vx * LOG_BOUNCE_FACTOR;
          if (ball.x < topLog.x) {
            ball.x = topLog.x - ball.radius;
          } else {
            ball.x = topLog.x + topLog.width + ball.radius;
          }
        }
      }
    }

    function draw() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      // Draw blocks (ground)
      for (let block of blocks) {
        if (block.type === 'grass') {
          ctx.drawImage(grassImg, block.x, block.y, block.width, block.height);
        } else if (block.type === 'sand') {
          ctx.drawImage(sandImg, block.x, block.y, block.width, block.height);
        }
      }

      // Draw moving top log
      ctx.drawImage(logImg, topLog.x, topLog.y, topLog.width, topLog.height);

      // Draw ball (simple white circle)
      ctx.beginPath();
      ctx.arc(ball.x, ball.y, ball.radius, 0, Math.PI * 2);
      ctx.fillStyle = ball.color;
      ctx.fill();
      ctx.strokeStyle = '#333';
      ctx.lineWidth = 2;
      ctx.stroke();
    }

    function resizeCanvas() {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
      groundY = canvas.height - BLOCK_HEIGHT;

      // keep ground stuck to bottom
      for (let block of blocks) {
        block.y = groundY;
      }

      // keep top log centered horizontally on resize
      topLog.y = canvas.height * 0.2;
      topLog.x = canvas.width / 2 - topLog.width / 2;

      // make sure ball isn't below ground after resize
      if (ball.y > groundY - ball.radius) {
        ball.y = groundY - ball.radius;
        ball.vy = 0;
      }
    }

    function gameLoop() {
      if (!gameRunning) return;
      update();
      draw();
      requestAnimationFrame(gameLoop);
    }

    function startGame() {
      document.body.style.backgroundImage = 'url("back.png")';
      document.body.style.backgroundSize = 'cover';
      document.body.style.backgroundPosition = 'center';
      document.body.style.backgroundRepeat = 'no-repeat';
      resizeCanvas();
      initBlocks();
      resetBall();
      gameOverScreen.classList.remove('visible');
      gameRunning = true;
      controlsEnabled = true;
      gameLoop();
    }

    function restartGame() {
      startGame();
    }

    restartBtn.addEventListener('click', restartGame);

    // Input state for log movement
    let controlsEnabled = false;
    const keys = {
      left: false,
      right: false
    };

    // When mouse is pressed (left click to move log)
    canvas.addEventListener('mousedown', (e) => {
      if (!gameRunning) return;

      if (e.button === 0) {
        // Left click to move log
        const rect = canvas.getBoundingClientRect();
        const mouseX = e.clientX - rect.left;
        topLog.x = mouseX - topLog.width / 2;
        if (topLog.x < 0) topLog.x = 0;
        if (topLog.x > canvas.width - topLog.width) topLog.x = canvas.width - topLog.width;
      }
    });

    // Arrow key handling for log movement (only while controlsEnabled)
    window.addEventListener('keydown', (e) => {
      if (!controlsEnabled) return;
      if (e.key === 'ArrowLeft') {
        keys.left = true;
      } else if (e.key === 'ArrowRight') {
        keys.right = true;
      } else if (e.key === ' ' && !ball.launched) {
        // Space to launch ball
        ball.launched = true;
        ball.vx = (Math.random() - 0.5) * (BALL_SPEED * 0.7);
        ball.vy = 0;
      }
    });

    window.addEventListener('keyup', (e) => {
      if (e.key === 'ArrowLeft') {
        keys.left = false;
      } else if (e.key === 'ArrowRight') {
        keys.right = false;
      }
    });

    // Start when page loads
    window.addEventListener('load', () => {
      resizeCanvas();
      startGame();
    });

    // Resize handler for full-screen behaviour
    window.addEventListener('resize', () => {
      resizeCanvas();
      // re-generate blocks to fill new width
      initBlocks();
    });
  </script>
</body>
</html>
